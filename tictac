package newtictactoe;

import java.util.Arrays;
public class Tictac {
private String winCon;

public String getWinCon() {
	return winCon;
}
public void setWinCon(String winCon) {
	this.winCon = winCon;
	 
}

	





	
public 	String convertor(Player p1,Player p2,String[] board) {
  String winner=null;
			for (int a = 0; a < 8; a++) {
				String line=null;
				switch (a) {
				case 0:
					line = board[0] + board[1] + board[2];
					break;
				case 1:
					line = board[3] + board[4] + board[5];
					break;
				case 2:
					line = board[6] + board[7] + board[8];
					break;
				case 3:
					line= board[0] + board[3] + board[6];
					break;
				case 4:
					line= board[1] + board[4] + board[7];
					break;
				case 5:
					line = board[2] + board[5] + board[8];
					break;
				case 6:
					line = board[0] + board[4] + board[8];
					break;
				case 7:
					line = board[2] + board[4] + board[6];
					break;
				
						}	
				if (line.equals("XXX"))
				{
				p1.printGamewinner();
				winner = "X";}
				else 
				if(line.equals("OOO") )
				{p2.printGamewinner();;
				 winner="O";}	
			}
				for (int a = 0; a < 9; a++) {
					if (Arrays.asList(board).contains(String.valueOf(a + 1))) {
						break;
					}
					else if (a == 8) {
						winner= "draw";
					}

				}                               
return winner;}

public 	int evaluator(String[] board) {
	 for (int a = 0; a < 3; a++)
	    {
	        if (board[a] == board[a+3] &&
	        		board[a] == board[a+3])
	        {
	            if (board[a] == "X")
	                return +1;
	            else if (board[a] == "O")
	                return -1;
	        }
	    }
	 
	    // Checking for Columns for X or O victory.
	    for (int a = 0; a < 3; a=a+3)
	    {
	        if (board[a] == board[a+1] &&
	        		board[a] == board[a+2])
	        {
	            if (board[a] == "X")
	                return +1;
	 
	            else if (board[a] == "O")
	                return -1;
	        }
	    }
	 
	    // Checking for Diagonals for X or O victory.
	    
	        if (board[0] == board[4] &&
	        		board[0] == board[8])
	        {
	            if (board[0] == "X")
	                return +1;
	 
	            else if (board[0] == "O")
	                return -1;
	        }
	    

	        if (board[2] == board[4] &&
	        		board[2] == board[6])
	        {
	            if (board[2] == "X")
	                return +1;
	 
	            else if (board[2] == "O")
	                return -1;
	        }
	    // Else if none of them have won then return 0
	    return 0;
	}			



public String[] newBoard(String board[],int numEntered,String symbol) {
	String s;    
	s=String.valueOf(numEntered);
	for (int counter=0;counter<9;counter++) {
		if(board[counter].equals(s)) 
			{
			board[counter]=symbol;                                 
			}	

}

return board;}

public String changeTurn(String turn,Player p1,Player p2)
{
	if (turn.equals(p1.getName()))
	{
turn=p2.getName() ;       
	}	 
else
if (turn.equals(p2.getName()))
		{
        turn=p1.getName();
		}
return turn;}
public String changeSymbol(String symbol,Player p1,Player p2)
{
	if (symbol.equals(p1.getSymbol()))
	{
symbol=p2.getSymbol() ;       
	}	 
else
if (symbol.equals(p2.getSymbol()))
		{
        symbol=p1.getSymbol();
		}
return symbol;}

public int randomNumGen() {
int number = (int) ((Math.random() * (9 - 1)) + 1);
return number;}

public Boolean movesLeft(String[] board)
{boolean help=true;
for (int a = 0; a < 9; a++) {
	if (Arrays.asList(board).contains(String.valueOf(a + 1))) {
		help=true;
		break;
	}
	else if (a == 8) {
		help=false;
	}
}
return help; } 
public int miniMax(String board[],int depth, Boolean isMax) {
	isMax=true;
	int score;
score= evaluator(board);
 
if (score == 1)
    return score;

if (score == -1)
    return score;

if (movesLeft(board)==true)
return 0;

if (isMax)
{
    int best = Integer.MIN_VALUE;

  
    for (int i = 0; i < 9; i++)
    {
        
      
            if ((board[i]!=("X"))&&(board[i]!=("O")))
            {
                
                board[i]=("O");

              int score2=miniMax(board, depth + 1, !isMax);
                best = Math.max(best, score2);

            
                board[i] =String.valueOf(i+1);
            }
        }
    
    return best;
}

else
{
    int best = Integer.MAX_VALUE;

    // Traverse all cells
    for (int i = 0; i < 9; i++)
    {
        
        if ((board[i]!=("X"))&&(board[i]!=("O")))
        {
            
            board[i]=("X");

               
            int score2=    miniMax(board,depth + 1,isMax);
            best = Math.min(best, score2);

                
               
                board[i] =String.valueOf(i+1);
            }
             
        }

    return best;
 }
}
  


public int findBestMove(String board[]){
    int bestVal = Integer.MIN_VALUE;
    int bestMove=-1;
   
 
    // Traverse all cells, evaluate minimax function
    // for all empty cells. And return the cell
    // with optimal value.
    for (int i = 0; i < 9; i++)
    {
     
            // Check if cell is empty
    	if ((board[i]!=("X"))&&(board[i]!=("O")))
            {
                // Make the move
                board[i] ="O";
 
                // compute evaluation function for this
                // move.
                int moveVal = miniMax(board, 0, false);
 
                // Undo the move
         
                board[i] =String.valueOf(i+1);
 
                // If the value of the current move is
                // more than the best value, then update
                // best/
                if (moveVal > bestVal)
                {bestVal = moveVal;
                    bestMove = i;
       
                    
                }
            }
        }
    
 
 
 
 

return bestMove+1;
}
}


